generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String         @id @default(cuid())
  email              String         @unique
  username           String?
  password           String
  age                Int?
  nativeLanguage     String?
  avatar             String?
  biography          String?
  slug               String?
  confirmationToken  String?
  resetPasswordToken String?
  refreshToken       String?
  isActive           Boolean        @default(false)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  deletedAt          DateTime?
  posts              Post[]
  conversations      Conversation[] @relation("ConversationUsers")
  // Relation for messages sent by the user
  sentMessages       Message[]      @relation("SentMessages")
  // Relation for messages received by the user
  receivedMessages   Message[]      @relation("ReceivedMessages")

  // Relation to the friendships the user has sent
  friendshipsSent     Friendship[] @relation("friendshipsSent")
  // Relation to the friendships the user has received
  friendshipsReceived Friendship[] @relation("friendshipsReceived")
  likes               Like[] // Relation to the likes made by the user
  comments            Comment[] // Relation to the comments made by the user
}

model Post {
  id               String    @id @default(cuid())
  content          String
  userId           String
  originalLanguage String
  emotion          String
  slug             String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  deletedAt        DateTime?
  // Relation to the user who created the post
  user             User?     @relation(fields: [userId], references: [id])
  comments         Comment[] // A post contains multiple comments
  tags             tag[]     @relation("PostTags")
  triggers         trigger[] @relation("PostTriggers")
  likes            Like[] // A post can have multiple likes
}

model tag {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())
  deletedAt DateTime?
  // Relation to the posts that have this tag
  posts     Post[]    @relation("PostTags")
}

model trigger {
  id        String    @id @default(cuid())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())
  deletedAt DateTime?
  // Relation to the posts that have this trigger
  posts     Post[]    @relation("PostTriggers")
}

model Like {
  id        String   @id @default(cuid())
  userId    String
  postId    String?
  commentId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relation to the user who liked the post or comment
  user    User     @relation(fields: [userId], references: [id])
  // Relation to the post that was liked
  post    Post?    @relation(fields: [postId], references: [id])
  // Relation to the comment that was liked
  comment Comment? @relation(fields: [commentId], references: [id])
}

model Comment {
  id        String    @id @default(cuid())
  content   String
  postId    String
  userId    String
  parentId  String? // Optional field to reference the parent comment
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())
  deletedAt DateTime?
  // Relation to the post the comment belongs to
  post      Post      @relation(fields: [postId], references: [id])
  // Relation to the user who created the comment
  user      User      @relation(fields: [userId], references: [id])
  // Self-referential relation to the parent comment
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  // Self-referential relation to the replies
  replies   Comment[] @relation("CommentReplies")
  likes     Like[] // A comment can have multiple likes
}

model Message {
  id         String    @id @default(cuid())
  senderId   String
  receiverId String
  senderName String
  content    String
  read       Boolean?  @default(false)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  deletedAt  DateTime?
  deletedBy  String?

  // Relation to the conversation the message belongs to
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  conversationId String
  // Relation to the user who sent the message
  sender         User         @relation("SentMessages", fields: [senderId], references: [id])
  // Relation to the user who received the message
  receiver       User         @relation("ReceivedMessages", fields: [receiverId], references: [id])
}

enum ConversationType {
  PRIVATE
  GROUP
}

model Conversation {
  id               String           @id @default(cuid())
  users            User[]           @relation("ConversationUsers")
  conversationType ConversationType @default(PRIVATE)
  messages         Message[] // A conversation contains multiple messages
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  deletedAt        DateTime?
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model Friendship {
  id          String           @id @default(cuid())
  requester   User             @relation("friendshipsSent", fields: [requesterId], references: [id])
  requesterId String
  receiver    User             @relation("friendshipsReceived", fields: [receiverId], references: [id])
  receiverId  String
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  deletedAt   DateTime?
  startedAt   DateTime?
  status      FriendshipStatus @default(PENDING)

  @@unique([requesterId, receiverId]) // Assure qu'il n'y ait qu'une seule relation d'amiti√© entre deux utilisateurs
}
